#include <iostream>   // Подключение библиотеки для ввода/вывода
#include <fstream>    // Подключение библиотеки для работы с файлами
#include <bitset>     // Подключение библиотеки для работы с битовым массивом
#include <chrono>     // Подключение библиотеки для измерения времени выполнения

using namespace std;  // Использование стандартного пространства имён для упрощения синтаксиса

// Константа для определения максимального числа, которое можем обработать (0 - 8388607)
const int MAX_NUMBERS = 8388608; // 2^23, то есть 8,388,608 чисел, соответствующих 1 МБ

// Константа для определения размера битового массива в байтах (1 байт = 8 битов)
const int BIT_ARRAY_SIZE = MAX_NUMBERS / 8; // 8,388,608 / 8 = 1,048,576 байт (1 МБ)

int main() {
    // Создание битового массива для хранения чисел от 0 до 8388607.
    // Каждый бит массива соответствует одному числу: 1 — число присутствует, 0 — отсутствует.
    bitset<MAX_NUMBERS> bitArray; // Битовый массив с размером 8,388,608 бит (1 бит на каждое число)

    // Открываем входной файл input.txt для чтения чисел
    ifstream inputFile("input.txt"); // Поток для чтения файла с числами

    // Открываем выходной файл output.txt для записи отсортированных чисел
    ofstream outputFile("output.txt"); // Поток для записи результата сортировки

    // Проверяем, удалось ли открыть входной файл
    if (!inputFile.is_open()) {
        cerr << "Ошибка: невозможно открыть файл input.txt" << endl; // Выводим сообщение об ошибке
        return 1; // Завершаем программу с кодом ошибки 1
    }

    int number; // Переменная для хранения текущего числа из файла

    // Засекаем время начала выполнения программы
    auto start = chrono::high_resolution_clock::now(); // Точка времени старта

    // Чтение чисел из входного файла и установка соответствующих битов
    while (inputFile >> number) { // Читаем числа из файла до конца
        // Проверяем, что число находится в допустимом диапазоне (от 0 до 8388607)
        if (number >= 0 && number < MAX_NUMBERS) {
            bitArray.set(number); // Устанавливаем бит для данного числа в 1 (число присутствует)
        }
    }
    inputFile.close(); // Закрываем входной файл, так как чтение завершено

    // Проходим по битовому массиву и записываем отсортированные числа в выходной файл
    for (int i = 0; i < MAX_NUMBERS; i++) {
        if (bitArray[i]) { // Если бит установлен (равен 1), значит это число было во входных данных
            outputFile << i << endl; // Записываем это число в выходной файл
        }
    }
    outputFile.close(); // Закрываем выходной файл после записи всех данных

    // Засекаем время окончания выполнения программы
    auto end = chrono::high_resolution_clock::now(); // Точка времени окончания

    // Вычисляем разницу между временем старта и временем окончания
    chrono::duration<double> duration = end - start; // Длительность выполнения программы в секундах

    // Выводим на экран время выполнения программы
    cout << "Время выполнения программы: " << duration.count() << " секунд" << endl;

    return 0; // Завершаем программу с кодом успешного выполнения
}
